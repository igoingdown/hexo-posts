---
style: summer

title: coolshell文章阅读

tags:
  - c++
  - 酷壳

---

看coolshell的时候我已经完成了从入门者到爱好者的转变，很多东西都知道，
但是这些东西有什么坑，有没有一些稀奇古怪的玩法，我是不知道的，
看coolshell实实在在地增长了自己的眼界。

<!-- more -->


1.  酷壳上面的文章也不一定是对的，C/C\+\+一直在更新，在变得更安全，比如
   	http://coolshell.cn/articles/4907.html
   	中的第一个例子，我在linux上得到的结果就不一样！我这边的输出结果是0，8！系统版本是debian，gcc版本是5.3.0。这个版本的gcc中，局部变量也会自动初始化了！很多东西都要自己试了才知道，这点对于C/C++尤其重要，因为自己看到的跟自己运行的结果可能大相径庭！文章中的第二个例子没分析程序的输出结果，甚至连提都没提……日了狗了！我在debian gcc4.7.2下得到的结果是：使用volatile和不使用volatile没什么区别！！！
2. 无符号整数溢出用最大的该类型最大的数取模，实际就是截断！
	有符号整数溢出是未定义的undefined！undefined是C/C\+\+中最可怕的事情！undefined的行为编译器想怎么干就怎么干！甚至可以玩彩蛋！目前比较流行的C/C\+\+编译器有gcc（g\+\+），这是Unix系列操作系统默认的编译器；Windows的编译器一般是VC++。
3. http://coolshell.cn/articles/5761.html
   这篇文章中的内存对齐讲的很好，内存对齐（memory alignment）是编译器的干的活，编译器计算一个结构体struct的大小时，是边计算边对齐的，因此结构体元素的声明顺序会影响结构体的大小！原顺序不变，容量需要细细思考，注意每种类型的默认占得字节数和类型变化处！在说明数组的地址时，数组或者指针的地址 + 或 - 操作，必须考虑内部数组的大小，而且高维要变到一维！注意64-bit系统中指针占8B！
5. http://coolshell.cn/articles/11377.html  
   这篇文章说到的访问结构体的实质是（&t + bias），t是结构体实例，即指针。bias就是元素相对于结构体的偏移量！第一个元素的bias为0！花了我好长时间终于理解了！
1. http://blog.csdn.net/haoel/article/details/24058  
	这篇文章写得太早了，是04年写的了！现在的C\+\+比04年的改变了很多，那时候的copy_on_write已经不能复现！！我在本地跑的结果跟博客中的结果完全不同！
	http://blog.csdn.net/haoel/article/details/1491219
	这篇文章中提到这种copy_on_write（COW）技术在多线程/进程环境下，极易出现错误，并预测在新版的C\+\+标准中被移除，还真是被移除了！
1. http://coolshell.cn/articles/10115.html
	这篇文章中有一段代码：
    ```c++
    struct {
       char a;
       int b;
    } b = { 2, 4 };
    ```
	这里面b定义了两次，为什么不报错？
	这里并没有定义两次，大括号分开了作用域！！所以这不是重复定义！只有链接的时候才会处理多个文件中重复定义的全局变量！所以那些所谓的抢符号和弱符号都只是相对于链接这个过程而言的！
