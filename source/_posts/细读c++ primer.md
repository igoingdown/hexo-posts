---
style: summer

title: c++ primer细读

tags:
  - c++
  - gcc
  - gdb
  - c
  - vector
---


读《c++ primer》，是自学c++的第一步，很多人也是从这里起步的，从这里起步，确实是一个很好的起点!

<!-- more -->


#### 内联函数

	C++讲究效率，内联函数指的是那些本身代码块比较小，但是运行时调用次数比较多的函数。如果不把这些函数设置为内联函数，调用的开销太大了！于是就想到把这些函数直接安插在主函数中，避免调用  以提高效率。但是现在的编译器相当智能，能自动统计函数的执行次数，会自己把相应的函数设置为内联函数。要注意的是：

1.  在类定义中（.h文件才有类定义）定义（不是声明）的函数默认为内联函数
2.  内联函数必须在 .h 文件中定义（不只是声明），因为编译器要知道内联函数的完整代码  才能在编译时把内敛函数的调用转化为真正的代码块
3.  内联函数的关键字（inline）对编译器而言只是一个建议，编译器是否采用还要看编译器的统计结果，即这里编译器其实有很大的发挥空间！
4.  内联的建议的发出有两种方式：一是用关键字inline声明，二是在类的声明体中直接定义函数。
5.  必须小心内联，因为内联函数的小小的改变会可能会导致大量代码的更改，这样很多依赖文件不得不重新编译，使得构建过程和编译过程不再独立（变得冗长）。


#### 函数重载

	函数重载的条件是没有歧义，有二义性的代码是不可以重载的

#### delete操作
使用delete语句时要注意delete 一个对象后要立马对该对象赋值（赋为NULL）且在delete之前要判断该对象是否为空，这样可防止对自由存储区的破坏（两次使用delete语句释放同一指针可能对存储区造成破坏）故delete语句经常这样写：

```cpp
if(ptr)
	delete ptr;
ptr=NULL;
```

#### 默认实参

函数声明中（不是函数定义中！函数声明中有默认实参，函数定义中就不用写默认实参了）的形参列表里，若一个形参设置了默认实参，则它之后的所有形参都必须设置默认实参。

#### C风格字符串和string的比较

C风格字符串必须要以`'\0'`**（杠铃）** 结尾，是`const char*`类型，不可以动态变化，而`string`类型是标准库类型和我们自己定义的类没有太大区别，可以动态变化，很方便。但是为了兼容C 的程序，一些地方必须用C风格字符串，例如文件流对象建立是绑定的文件的文件名必须是C风格字符串

#### 类的关系

1.  没有关系：绝大多数时候就是这种关系，由封装的特点决定！
2.  继承：本质是“是”的关系，在继承之前先问一下这两个类之间是不是“是”的关系，继承主要是为了实现代码重用。
3.  复合（组合）：即包含或者知道的关系，包含即一个类的对象作为另一个类的成员变量，这种情况很常见！但是也有一些情况下，如狗主人和狗的关系，狗主人和狗类是相互包含的，这种互相包含的情况可用指针来实现，这就是知道的关系。

#### 继承与派生

1.  子类继承基类时，为子类分配的内存空间中完整地包括了基类的所有成员变量的所占空间和子类自己独有的成员变量的所占空间，这是因为构造子类对象时必须先构造出基类对象，然后再添加内容，但是基类的private成员不可访问（上锁）！
2.  子类对象构造过程中，基类、子类的类成员和子类的构造函数依次执行，且先构造后析构。
3.  C++的默认继承方式是私有继承！
4.  C++的public继承就是“is-a”的关系，就是说基类的所有接口在子类中都应该有效！如果发生非virtual函数发生在基类和子类中发生重名，必须使用using base class::function()导入！这就是C++的public继承的含义。
5.  C++的private继承是由……实现（is-implemented-in-terms-of）的含义，或者说“has-a”的意思。

#### 虚函数
1. 虚函数的声明中的virtual关键字放在最前面，在定义中不加virtual关键字。
2. 构造函数和静态成员函数不能用virtual关键字。
3. 多态对间接派生关系依然适用。
4. 纯虚函数就是连函数体都没有的函数，故将函数赋值为0（函数指针!!!）。
5. 用基类的指针数组存放指向派生类对象的指针，遍历该数组就可以通过多态自动实现对派生类对象的访问，这在实际编程中很常用！
6. 在非构造函数和非析构函数中调用虚函数也是多态！
7. 派生类中和基类的  虚函数同函数名同参数表的函数即使不加virtual关键字也自动被转化成虚函数。
8. 虚函数表是编译器自己加的，用于“动态联编”，即多态的一种实现方式。因此这些类的成员变量中会多出一个指向该虚函数表的指针（占四个字节）。虽然这样很方便但是增加了时间和空间上的开销。
9. 如果一个类中有虚函数，则一定要把析构函数设置为虚函数！
1. C++的虚函数的访问靠虚函数表实现：每个对象在其内存空间的最开始的位置保存一个指向虚函数表起始地址的指针（这样可以保证访问虚函数有最好的性能），这个指针就是虚指针（虚函数指针），虚函数表中的虚函数（的起始地址）连续存放，最后有结束标志符。
1. Interface class或者reference class需要将其接口全部设为虚函数或者纯虚函数，以实现接口和实现的分离。
2. 虚函数示例代码

```cpp
#include <iostream>
#include <vector>

using namespace std;


class C1{
private:
	int a;
	virtual void f1() {
		cout << "c1" << endl;
	}

	void f2() {
		cout << "f2" << endl;
	}

	void f2() const {
		cout << "f2 const" << endl;
	}
	// 两个f2构成重载是因为隐藏的this指针不同补全之后分别为
	// void f2(C1 *const this)
	// void f2(const C1 *const this)

	void f10(const int* a) {
		cout << "f10" << endl;
	}

	void f10(int *a) {
		cout << "f10 no const" << endl;
	}

	void f5(int &a) {
		cout << "f5" << endl;
	}
	void f5(const int &a) {
		cout << "f5 const" << endl;
	}

	// 同f2,f10和f5也属于正确的重载

};

class C: public C1 {
	void f3() {
		cout << "f3" << endl;
	}
};



int main() {
	C1 c;
	int a = 10;
	cout << sizeof(a) << endl;   // 4
	cout << sizeof(c) << endl;   // 16, 内存以8B对齐，有虚函数表指针vptr(指向vtbl)，
	//  vtbl是类的，不是对象的，因为vptr是类的，不是对象的!
	// 通过对象实例的地址得到虚函数表，是因为 vptr 指针位于对象实例的最前面
	//     这是由编译器决定的，主要是为了保证取到虚函数表有最高的性能——如果有多层继承或是多重继承的情况下
	return 0;
}
```

